{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, NETWORK_FAILURE, STORAGE_KEY } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthUnknownError, isAuthError } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse } from './lib/fetch';\nimport { decodeBase64URL, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS\n};\nexport default class GoTrueClient {\n  /**\n   * Create a new client for use in the browser.\n   */\n  constructor(options) {\n    this.stateChangeEmitters = new Map();\n    this.networkRetries = 0;\n    this.refreshingDeferred = null;\n    /**\n     * Keeps track of the async client initialization.\n     * When null or not yet resolved the auth state is `unknown`\n     * Once resolved the the auth state is known and it's save to call any further client methods.\n     * Keep extra care to never reject or throw uncaught errors\n     */\n\n    this.initializePromise = null;\n    this.detectSessionInUrl = true;\n    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.inMemorySession = null;\n    this.storageKey = settings.storageKey;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.storage = settings.storage || localStorageAdapter;\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch\n    });\n    this.url = settings.url;\n    this.headers = settings.headers;\n    this.fetch = resolveFetch(settings.fetch);\n    this.detectSessionInUrl = settings.detectSessionInUrl;\n    this.initialize();\n  }\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n\n\n  initialize() {\n    if (!this.initializePromise) {\n      this.initializePromise = this._initialize();\n    }\n\n    return this.initializePromise;\n  }\n  /**\n   * IMPORTANT:\n   * 1. Never throw in this method, as it is called from the constructor\n   * 2. Never return a session from this method as it would be cached over\n   *    the whole lifetime of the client\n   */\n\n\n  _initialize() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.initializePromise) {\n        return this.initializePromise;\n      }\n\n      try {\n        if (this.detectSessionInUrl && this._isImplicitGrantFlow()) {\n          const {\n            data,\n            error\n          } = yield this._getSessionFromUrl();\n\n          if (error) {\n            // failed login attempt via url,\n            // remove old session as in verifyOtp, signUp and signInWith*\n            yield this._removeSession();\n            return {\n              error\n            };\n          }\n\n          const {\n            session,\n            redirectType\n          } = data;\n          yield this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN', session);\n\n          if (redirectType === 'recovery') {\n            this._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n          }\n\n          return {\n            error: null\n          };\n        } // no login attempt via callback url try to recover session from storage\n\n\n        yield this._recoverAndRefresh();\n        return {\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            error\n          };\n        }\n\n        return {\n          error: new AuthUnknownError('Unexpected error during initialization', error)\n        };\n      } finally {\n        this._handleVisibilityChange();\n      }\n    });\n  }\n  /**\n   * Creates a new user.\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n\n\n  signUp(credentials) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n\n        if ('email' in credentials) {\n          const {\n            email,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n            headers: this.headers,\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n            body: {\n              email,\n              password,\n              data: options === null || options === void 0 ? void 0 : options.data,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else if ('phone' in credentials) {\n          const {\n            phone,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              data: options === null || options === void 0 ? void 0 : options.data,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n        }\n\n        const {\n          data,\n          error\n        } = res;\n\n        if (error || !data) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: error\n          };\n        }\n\n        const session = data.session;\n        const user = data.user;\n\n        if (data.session) {\n          yield this._saveSession(data.session);\n\n          this._notifyAllSubscribers('SIGNED_IN', session);\n        }\n\n        return {\n          data: {\n            user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in an existing user with an email and password or phone and password.\n   */\n\n\n  signInWithPassword(credentials) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n\n        if ('email' in credentials) {\n          const {\n            email,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              email,\n              password,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else if ('phone' in credentials) {\n          const {\n            phone,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n        }\n\n        const {\n          data,\n          error\n        } = res;\n        if (error || !data) return {\n          data: {\n            user: null,\n            session: null\n          },\n          error\n        };\n\n        if (data.session) {\n          yield this._saveSession(data.session);\n\n          this._notifyAllSubscribers('SIGNED_IN', data.session);\n        }\n\n        return {\n          data,\n          error\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in an existing user via a third-party provider.\n   */\n\n\n  signInWithOAuth(credentials) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._removeSession();\n      return this._handleProviderSignIn(credentials.provider, {\n        redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n        scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n        queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams\n      });\n    });\n  }\n  /**\n   * Log in a user using magiclink or a one-time password (OTP).\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n   */\n\n\n  signInWithOtp(credentials) {\n    var _a, _b, _c, _d;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n\n        if ('email' in credentials) {\n          const {\n            email,\n            options\n          } = credentials;\n          const {\n            error\n          } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              email,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n          });\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        if ('phone' in credentials) {\n          const {\n            phone,\n            options\n          } = credentials;\n          const {\n            error\n          } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              phone,\n              data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n              create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            }\n          });\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   */\n\n\n  verifyOtp(params) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/verify`, {\n          headers: this.headers,\n          body: Object.assign(Object.assign({}, params), {\n            gotrue_meta_security: {\n              captchaToken: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken\n            }\n          }),\n          redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n          xform: _sessionResponse\n        });\n\n        if (error) {\n          throw error;\n        }\n\n        if (!data) {\n          throw 'An error occurred on token verification.';\n        }\n\n        const session = data.session;\n        const user = data.user;\n\n        if (session === null || session === void 0 ? void 0 : session.access_token) {\n          yield this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN', session);\n        }\n\n        return {\n          data: {\n            user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Returns the session, refreshing it if necessary.\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n   */\n\n\n  getSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // make sure we've read the session from the url if there is one\n      // save to just await, as long we make sure _initialize() never throws\n      yield this.initializePromise;\n      let currentSession = null;\n\n      if (this.persistSession) {\n        const maybeSession = yield getItemAsync(this.storage, this.storageKey);\n\n        if (maybeSession !== null) {\n          if (this._isValidSession(maybeSession)) {\n            currentSession = maybeSession;\n          } else {\n            yield this._removeSession();\n          }\n        }\n      } else {\n        currentSession = this.inMemorySession;\n      }\n\n      if (!currentSession) {\n        return {\n          data: {\n            session: null\n          },\n          error: null\n        };\n      }\n\n      const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;\n\n      if (!hasExpired) {\n        return {\n          data: {\n            session: currentSession\n          },\n          error: null\n        };\n      }\n\n      const {\n        session,\n        error\n      } = yield this._callRefreshToken(currentSession.refresh_token);\n\n      if (error) {\n        return {\n          data: {\n            session: null\n          },\n          error\n        };\n      }\n\n      return {\n        data: {\n          session\n        },\n        error: null\n      };\n    });\n  }\n  /**\n   * Gets the current user details if there is an existing session.\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n   */\n\n\n  getUser(jwt) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!jwt) {\n          const {\n            data,\n            error\n          } = yield this.getSession();\n\n          if (error) {\n            throw error;\n          } // Default to Authorization header if there is no existing session\n\n\n          jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n        }\n\n        return yield _request(this.fetch, 'GET', `${this.url}/user`, {\n          headers: this.headers,\n          jwt: jwt,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n\n\n  updateUser(attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          throw sessionError;\n        }\n\n        if (!sessionData.session) {\n          throw new AuthSessionMissingError();\n        }\n\n        const session = sessionData.session;\n        const {\n          data,\n          error: userError\n        } = yield _request(this.fetch, 'PUT', `${this.url}/user`, {\n          headers: this.headers,\n          body: attributes,\n          jwt: session.access_token,\n          xform: _userResponse\n        });\n        if (userError) throw userError;\n        session.user = data.user;\n        yield this._saveSession(session);\n\n        this._notifyAllSubscribers('USER_UPDATED', session);\n\n        return {\n          data: {\n            user: session.user\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n   * If the refresh token in the current session is invalid and the current session has expired, an error will be thrown.\n   * If the current session does not contain at expires_at field, setSession will use the exp claim defined in the access token.\n   * @param currentSession The current session that minimally contains an access token, refresh token and a user.\n   */\n\n\n  setSession(currentSession) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const timeNow = Date.now() / 1000;\n        let expiresAt = timeNow;\n        let hasExpired = true;\n        let session = null;\n\n        if (currentSession.access_token && currentSession.access_token.split('.')[1]) {\n          const payload = JSON.parse(decodeBase64URL(currentSession.access_token.split('.')[1]));\n\n          if (payload.exp) {\n            expiresAt = payload.exp;\n            hasExpired = expiresAt <= timeNow;\n          }\n        }\n\n        if (hasExpired) {\n          if (!currentSession.refresh_token) {\n            throw new AuthSessionMissingError();\n          }\n\n          const {\n            data,\n            error\n          } = yield this._refreshAccessToken(currentSession.refresh_token);\n\n          if (error) {\n            return {\n              data: {\n                session: null,\n                user: null\n              },\n              error: error\n            };\n          }\n\n          if (!data.session) {\n            return {\n              data: {\n                session: null,\n                user: null\n              },\n              error: null\n            };\n          }\n\n          session = data.session;\n        } else {\n          const {\n            data,\n            error\n          } = yield this.getUser(currentSession.access_token);\n\n          if (error) {\n            throw error;\n          }\n\n          session = {\n            access_token: currentSession.access_token,\n            refresh_token: currentSession.refresh_token,\n            user: data.user,\n            token_type: 'bearer',\n            expires_in: expiresAt - timeNow,\n            expires_at: expiresAt\n          };\n        }\n\n        yield this._saveSession(session);\n\n        this._notifyAllSubscribers('TOKEN_REFRESHED', session);\n\n        return {\n          data: {\n            session,\n            user: session.user\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Gets the session data from a URL string\n   */\n\n\n  _getSessionFromUrl() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.');\n\n        if (!this._isImplicitGrantFlow()) {\n          throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n        }\n\n        const error_description = getParameterByName('error_description');\n\n        if (error_description) {\n          const error_code = getParameterByName('error_code');\n          if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.');\n          const error = getParameterByName('error');\n          if (!error) throw new AuthImplicitGrantRedirectError('No error detected.');\n          throw new AuthImplicitGrantRedirectError(error_description, {\n            error,\n            code: error_code\n          });\n        }\n\n        const provider_token = getParameterByName('provider_token');\n        const provider_refresh_token = getParameterByName('provider_refresh_token');\n        const access_token = getParameterByName('access_token');\n        if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.');\n        const expires_in = getParameterByName('expires_in');\n        if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n        const refresh_token = getParameterByName('refresh_token');\n        if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n        const token_type = getParameterByName('token_type');\n        if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.');\n        const timeNow = Math.round(Date.now() / 1000);\n        const expires_at = timeNow + parseInt(expires_in);\n        const {\n          data,\n          error\n        } = yield this.getUser(access_token);\n        if (error) throw error;\n        const user = data.user;\n        const session = {\n          provider_token,\n          provider_refresh_token,\n          access_token,\n          expires_in: parseInt(expires_in),\n          expires_at,\n          refresh_token,\n          token_type,\n          user\n        };\n        const redirectType = getParameterByName('type'); // Remove tokens from URL\n\n        window.location.hash = '';\n        return {\n          data: {\n            session,\n            redirectType\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              redirectType: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n   */\n\n\n  _isImplicitGrantFlow() {\n    return isBrowser() && (Boolean(getParameterByName('access_token')) || Boolean(getParameterByName('error_description')));\n  }\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n   */\n\n\n  signOut() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data,\n        error: sessionError\n      } = yield this.getSession();\n\n      if (sessionError) {\n        return {\n          error: sessionError\n        };\n      }\n\n      const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n\n      if (accessToken) {\n        const {\n          error\n        } = yield this.admin.signOut(accessToken);\n        if (error) return {\n          error\n        };\n      }\n\n      yield this._removeSession();\n\n      this._notifyAllSubscribers('SIGNED_OUT', null);\n\n      return {\n        error: null\n      };\n    });\n  }\n  /**\n   * Receive a notification every time an auth event happens.\n   * @param callback A callback function to be invoked when an auth event happens.\n   */\n\n\n  onAuthStateChange(callback) {\n    const id = uuid();\n    const subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.stateChangeEmitters.delete(id);\n      }\n    };\n    this.stateChangeEmitters.set(id, subscription);\n    return {\n      data: {\n        subscription\n      }\n    };\n  }\n  /**\n   * Sends a password reset request to an email address.\n   * @param email The email address of the user.\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n   */\n\n\n  resetPasswordForEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, 'POST', `${this.url}/recover`, {\n          body: {\n            email,\n            gotrue_meta_security: {\n              captcha_token: options.captchaToken\n            }\n          },\n          headers: this.headers,\n          redirectTo: options.redirectTo\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n\n\n  _refreshAccessToken(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n          body: {\n            refresh_token: refreshToken\n          },\n          headers: this.headers,\n          xform: _sessionResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n\n  _isValidSession(maybeSession) {\n    const isValidSession = typeof maybeSession === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;\n    return isValidSession;\n  }\n\n  _handleProviderSignIn(provider) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const url = this._getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams\n    }); // try to open on the browser\n\n\n    if (isBrowser()) {\n      window.location.href = url;\n    }\n\n    return {\n      data: {\n        provider,\n        url\n      },\n      error: null\n    };\n  }\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n\n\n  _recoverAndRefresh() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const currentSession = yield getItemAsync(this.storage, this.storageKey);\n\n        if (!this._isValidSession(currentSession)) {\n          if (currentSession !== null) {\n            yield this._removeSession();\n          }\n\n          return;\n        }\n\n        const timeNow = Math.round(Date.now() / 1000);\n\n        if (((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN) {\n          if (this.autoRefreshToken && currentSession.refresh_token) {\n            this.networkRetries++;\n            const {\n              error\n            } = yield this._callRefreshToken(currentSession.refresh_token);\n\n            if (error) {\n              console.log(error.message);\n\n              if (error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) {\n                if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n                this.refreshTokenTimer = setTimeout(() => this._recoverAndRefresh(), Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                );\n                return;\n              }\n\n              yield this._removeSession();\n            }\n\n            this.networkRetries = 0;\n          } else {\n            yield this._removeSession();\n          }\n        } else {\n          if (this.persistSession) {\n            yield this._saveSession(currentSession);\n          }\n\n          this._notifyAllSubscribers('SIGNED_IN', currentSession);\n        }\n      } catch (err) {\n        console.error(err);\n        return;\n      }\n    });\n  }\n\n  _callRefreshToken(refreshToken) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      // refreshing is already in progress\n      if (this.refreshingDeferred) {\n        return this.refreshingDeferred.promise;\n      }\n\n      try {\n        this.refreshingDeferred = new Deferred();\n\n        if (!refreshToken) {\n          throw new AuthSessionMissingError();\n        }\n\n        const {\n          data,\n          error\n        } = yield this._refreshAccessToken(refreshToken);\n        if (error) throw error;\n        if (!data.session) throw new AuthSessionMissingError();\n        yield this._saveSession(data.session);\n\n        this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n\n        const result = {\n          session: data.session,\n          error: null\n        };\n        this.refreshingDeferred.resolve(result);\n        return result;\n      } catch (error) {\n        if (isAuthError(error)) {\n          const result = {\n            session: null,\n            error\n          };\n          (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n          return result;\n        }\n\n        (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n        throw error;\n      } finally {\n        this.refreshingDeferred = null;\n      }\n    });\n  }\n\n  _notifyAllSubscribers(event, session) {\n    this.stateChangeEmitters.forEach(x => x.callback(event, session));\n  }\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n\n\n  _saveSession(session) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.persistSession) {\n        this.inMemorySession = session;\n      }\n\n      const expiresAt = session.expires_at;\n\n      if (expiresAt) {\n        const timeNow = Math.round(Date.now() / 1000);\n        const expiresIn = expiresAt - timeNow;\n        const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n\n        this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n      }\n\n      if (this.persistSession && session.expires_at) {\n        yield this._persistSession(session);\n      }\n    });\n  }\n\n  _persistSession(currentSession) {\n    return setItemAsync(this.storage, this.storageKey, currentSession);\n  }\n\n  _removeSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.persistSession) {\n        yield removeItemAsync(this.storage, this.storageKey);\n      } else {\n        this.inMemorySession = null;\n      }\n\n      if (this.refreshTokenTimer) {\n        clearTimeout(this.refreshTokenTimer);\n      }\n    });\n  }\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds.\n   * @param session The current session.\n   */\n\n\n  _startAutoRefreshToken(value) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n    if (value <= 0 || !this.autoRefreshToken) return;\n    this.refreshTokenTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n      this.networkRetries++;\n      const {\n        data: {\n          session\n        },\n        error: sessionError\n      } = yield this.getSession();\n\n      if (!sessionError && session) {\n        const {\n          error\n        } = yield this._callRefreshToken(session.refresh_token);\n        if (!error) this.networkRetries = 0;\n        if (error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n      }\n    }), value);\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n  }\n\n  _handleVisibilityChange() {\n    if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n      return false;\n    }\n\n    try {\n      window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', () => __awaiter(this, void 0, void 0, function* () {\n        if (document.visibilityState === 'visible') {\n          yield this.initializePromise;\n          yield this._recoverAndRefresh();\n        }\n      }));\n    } catch (error) {\n      console.error('_handleVisibilityChange', error);\n    }\n  }\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n   */\n\n\n  _getUrlForProvider(provider, options) {\n    const urlParams = [`provider=${encodeURIComponent(provider)}`];\n\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.queryParams) {\n      const query = new URLSearchParams(options.queryParams);\n      urlParams.push(query.toString());\n    }\n\n    return `${this.url}/authorize?${urlParams.join('&')}`;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["GoTrueAdminApi","DEFAULT_HEADERS","EXPIRY_MARGIN","GOTRUE_URL","NETWORK_FAILURE","STORAGE_KEY","AuthImplicitGrantRedirectError","AuthInvalidCredentialsError","AuthRetryableFetchError","AuthSessionMissingError","AuthUnknownError","isAuthError","_request","_sessionResponse","_userResponse","decodeBase64URL","Deferred","getItemAsync","getParameterByName","isBrowser","removeItemAsync","resolveFetch","setItemAsync","uuid","localStorageAdapter","polyfillGlobalThis","DEFAULT_OPTIONS","url","storageKey","autoRefreshToken","persistSession","detectSessionInUrl","headers","GoTrueClient","constructor","options","Map","settings","inMemorySession","storage","admin","fetch","initialize","initializePromise","_initialize","_isImplicitGrantFlow","data","error","_getSessionFromUrl","_removeSession","session","redirectType","_saveSession","_notifyAllSubscribers","_recoverAndRefresh","_handleVisibilityChange","signUp","credentials","res","email","password","redirectTo","emailRedirectTo","body","gotrue_meta_security","captcha_token","captchaToken","xform","phone","user","signInWithPassword","signInWithOAuth","_handleProviderSignIn","provider","_a","scopes","_b","queryParams","_c","signInWithOtp","create_user","shouldCreateUser","_d","verifyOtp","params","access_token","getSession","currentSession","maybeSession","_isValidSession","hasExpired","expires_at","Date","now","_callRefreshToken","refresh_token","getUser","jwt","undefined","updateUser","attributes","sessionData","sessionError","userError","setSession","timeNow","expiresAt","split","payload","JSON","parse","exp","_refreshAccessToken","token_type","expires_in","error_description","error_code","code","provider_token","provider_refresh_token","Math","round","parseInt","window","location","hash","Boolean","signOut","accessToken","onAuthStateChange","callback","id","subscription","unsubscribe","stateChangeEmitters","delete","set","resetPasswordForEmail","refreshToken","isValidSession","_getUrlForProvider","href","Infinity","networkRetries","console","log","message","MAX_RETRIES","refreshTokenTimer","clearTimeout","setTimeout","RETRY_INTERVAL","err","refreshingDeferred","promise","result","resolve","reject","event","forEach","x","expiresIn","refreshDurationBeforeExpires","_startAutoRefreshToken","_persistSession","value","__awaiter","unref","addEventListener","document","visibilityState","urlParams","encodeURIComponent","push","query","URLSearchParams","toString","join"],"sourceRoot":"","sources":["../../src/GoTrueClient.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}